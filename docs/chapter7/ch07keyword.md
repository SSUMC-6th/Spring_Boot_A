# keyword1: 영속성 컨텍스트

### 영속성 컨텍스트

---

- JPA는 ORM 기술 → 객체와 테이블을 연결한다.
    - JPA에서는 테이블과 매핑되는 엔티티 객체 정보를
        
        영속성 컨텍스트를 통해 애플리케이션 내에서 오래 지속되도록 보관한다.
        
- 영속성 컨텍스트는 눈에 보이지 않는 논리적인 개념
- 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB 역할

일반적인 영속성 컨텍스트는 트랜잭션이 시작될 때 생성되고, 트랜잭션이 끝날 때 (커밋 또는 롤백) 종료된다. (Transaction-scope 영속성 컨텍스트)

하지만 Extended-scope 영속성 컨텍스트는 영속성 컨텍스트가 여러 트랜잭션에 걸쳐 유지될 수 있다.

- 엔터티 매니저를 통해 엔터티를 저장/조회하면
    
    엔터티 매니저는 영속성 컨텍스트에 엔터티를 보관하고 관리한다.
    
- 영속성 컨텍스트는 엔터티 매니저를 생성할 때 하나 만들어지며,
    
    엔터티 매니저를 통해 영속성 컨텍스트에 접근한다.
    


> em.persist(member); 
> → 엔터티 매니저를 사용해 member 엔터티를 영속성 컨텍스트에 저장한다는 의미


### 엔터티의 생명주기

---

1. `비영속`(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 엔터티 객체 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태
    
    ```java
    Member member = new Member();
    ```
    
2. `영속`(managed): 영속성 컨텍스트에 저장된 상태
    - 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태
    - 엔터티는 영속성 컨텍스트에 의해 관리됨
    
    ```java
    em.persist(member);
    ```
    
3. `준영속`(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 더이상 관리하지 않을 때
    - 특정 엔티티를 준영속 상태로 만드려면 `em.datach()`를 호출
    - 준영속 상태는 1차 캐시, 지연 로딩을 포함한 영속성 컨텍스트의 어떠한 기능도 동작하지 않는다.
        
        식별자 값을 가지고 있다.
        
    
    ```java
    // 엔티티를 영속성 컨텍스트에서 분리해 준영속 상태로 만든다.
    em.detach(member);
    // 영속성 콘텍스트를 비워도 관리되던 엔티티는 준영속 상태가 된다.
    em.claer();
    // 영속성 콘텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
    em.close();
    ```
    
4. `삭제`(removed): 삭제된 상태
    - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제
    
    ```java
    em.remove(member);
    ```
    

### 영속성 컨텍스트의 특징

---

1. 영속성 컨텍스트는 엔터티를 식별자 값으로 구분한다. 
    
    따라서 영속 상태는 식별자 값이 반드시 있어야 한다.
    
2. JPA는 보통 **트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔터티를** 
    
    **데이터 베이스에 반영**하는데,  이를 `flush`라 한다.
    
- 플러시는 영속성 컨텍스트를 비우지 않는다.
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 역할이다.
(트랜잭션이 종료될 때, 즉 커밋될 때 비워짐)
- 플러시의 개념은 트랜잭션이라는 작업 단위에 중요 → 커밋 직전에만 동기화하면 된다.

### **영속성 컨텍스트가 엔티티를 관리할 때의 장점**

---

1. **1차 캐시 (한 트랜잭션의 커밋 전까지, 한 트랜잭션 내에서 유효함)**
    - 영속성 컨텍스트 내부의 캐시로, 영속 상태의 엔티티를 이곳에 저장한다.
    - 1차 캐시의 키는 식별자 값(DB의 기본 키)이고 값은 엔티티 인스턴스이다.
    - 조회하는 방법
        
        ```java
        // em.find(엔티티 클래스 타입, 식별자 값);
        Member member = em.find(Member.class, "member1");
        ```
        
    - 조회의 흐름
        
        1. 1차 캐시에서 엔티티를 찾는다
        
        2. 있으면 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
        
        3. 없으면 데이터베이스에서 조회한다.
        
        4. 조회한 데이터로 엔티티를 생성해 1차 캐시에 저장한다. (엔티티를 영속상태로 만든다)
        
        5. 조회한 엔티티를 반환한다.
        

2. **동일성 보장**
    - 영속성 컨텍스트는 엔티티의 동일성을 보장한다.
    - 실제 인스턴스가 같다.
        
        ```java
        Member a = em.find(Member.class, "member1");
        Member b = em.find(Member.class, "member1");
        System.out.print(a==b) // true
        ```
        

3. **트랙잭션을 지원하는 쓰기 지연**
    - 엔터티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
    - 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보낸다.
        
        → 이것을 트랜잭션을 지원하는 `쓰기 지연`이라 한다.
        

4. **변경 감지**
    - JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터를 변경하면 된다.
    - 변경감지의 흐름
        1. **트랙잭션을 커밋**하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
        2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
        3. 변경된 엔티티가 있으면 **수정 쿼리를 생성**해서 쓰기 지연 SQL 저장소에 저장한다.
        4. 쓰기 지연 저장소의 SQL을 플러시한다.
        5. 데이터베이스 트랜잭션을 커밋한다.
    

    > 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다.
    
    

5. 지연 로딩
    - JPA에서는 데이터를 조회할 때 `즉시 로딩(EAGER)`과 `지연 로딩(LAZY)` 두 가지 방식이 있다.
        - 즉시 로딩: 데이터를 조회할 때 연관된 데이터까지 한 번에 불러오는 것
        - 지연 로딩: 필요한 시점에 연관된 데이터를 불러오는 것
    - 즉시 로딩 : `@ManyToOne(fetch = FetchType.EAGER)`
    - 지연 로딩 : `@ManyToOne(fetch = FetchType.LAZY)`

### 플러시

---

- `플러시`: 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- 영속성 컨텍스트의 엔티티를 지우는게 아니라, 변경 내용을 데이터베이스에 동기화하는 것이다.

- 플러시의 흐름
    
    1. 변경 감지가 동작해서 스냅샷과 비교해서 수정된 엔티티를 찾는다.
    
    2. 수정된 엔티티에 대해서 수정 쿼리를 만들고 SQL 저장소에 등록한다.
    
    3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
    

- 플러시하는 방법
    
    1. `em.flush()`
    
    2. 트랙잭션 커밋시 자동 호출
    
    3. JPQL 쿼리 실행시 자동 호출


# keyword2: 양방향 매핑

> JPA에서는 두 엔티티 사이의 연관 관계를 정의할 때 기본적으로 단방향으로 정의한다. 
> 이로 인해 DB 테이블에서 외래키를 기준으로 하여 두 테이블 간의 연관된 데이터를 조회할 수 있는 것과 달리, JPA에서 단방향 연관 관계가 정의된 상태에서는 한 쪽 엔티티 객체는 연관 관계인 엔티티 객체를 조회할 수 있으나, 반대쪽 엔티티 객체는 어떤 엔티티 객체와 연관 관계를 갖는지 알 수 없다.


따라서 엔터티 양쪽에서 동등하게 연관되는 객체의 정보를 얻기 위해 양방향 연관 관계를 정의한다.

### 양방향 연관 관계의 규칙

---

- 연관 관계를 갖는 두 객체 중 하나를 `연관 관계의 주인`으로 지정
- 연관 관계의 주인만이 외래키를 관리(삽입, 수정, 삭제)
- **주인이 아닌 쪽은 읽기만 가능**
- 주인은 `mappedBy` 속성을 사용하지 않음
- 주인이 아닌 쪽은 `mappedBy` 속성을 사용하여 주인 지정

### 연관 관계의 주인

---

- 연관 관계의 주인을 정할 때는 외래키가 존재하는 쪽을 주인으로 지정해야 한다.
- 이는 N:1 관계에서 N에 해당하는 쪽이기 때문에
    
    `@ManyToOne`에는 주인을 지정하는 `mappedBy` 속성이 존재하지 않는다. 
    

- 주인을 지정하게 되면 두 엔티티 사이의 외래키는 연관 관계의 주인만 관리할 수 있고,
    
    주인이 아닌 쪽은 연관된 객체를 **읽는 것만 가능**하다.
    
    - 즉, 실제 DB 상에 데이터와 매핑되지는 않는다.
    - 예시로 Board - User 구조에서 User 객체의 boards에 있는
        
        Board 객체를 수정하거나 삭제해도 DB에 있는 Board 테이블에는 아무일도 일어나지 않는다. 
        

### 하지만 양방향 연관 관계는 잘 사용하지 않는다

---

사실 양방향 연관 관계를 실제로 사용할 일은 많지 않다고 한다. 양방향 연관 관계는 고려해야할 사항이 있는데다가, 부모 엔티티 객체에 해당하는 자식 엔티티 객체들을 확인하고 싶을 땐 굳이 양방향 연관 관계를 사용하지 않고 자식 테이블에서 외래키를 기준으로 조회하면 된다.

예를 들어, Board - User 구조에서 사용자가 작성한 글의 목록을 조회하는 경우를 위해 양방향 연관 관계를 설정했지만 사실 그냥 Board 테이블에서 외래키인 user_id를 기준으로 조회하면 된다.

그럼에도 불구하고 양방향 연관 관계를 사용하게 되는 경우는 부모 엔티티 객체를 조회할 때 해당 객체와 연관된 자식 엔티티 객체까지 함께 조회하고 싶을 때 등이 있다. 실제로는 단방향 연관 관계로도 충분히 가능한 일이지만 조금 더 객체지향적인 개발을 하고싶을 때 양방향 연관 관계를 사용할 수 있다고 한다. 다만, 이러한 경우에도 양방향 연관 관계를 사용하기보다는 둘 사이의 연계성을 끊고 별개로 사용하는 것을 권장한다.




# keyword3: N+1 문제

### N+1 문제란?

---

- 연관 관계에서 발생하는 이슈
- 비효율적인 쿼리가 다수 발생하여 성능 저하를 유발
- 연관 관계가 설정된 엔티티를 조회할 경우에,
    
    만약 `1개의 쿼리`로 `N개의 엔티티`를 조회했다면,
    
    각 엔티티에 대해 추가로 `N개의 쿼리`가 발생하여 연관된 엔티티를 조회하게 되는 문제
    

- 실제 실행되는 쿼리 예시
    1.  쿼리
        
        ```sql
        SELECT * FROM owner; //N개의 owner 보유
        ```
        
    2. 쿼리
        
        ```sql
        SELECT * FROM cat WHERE owner_id = 1;
        SELECT * FROM cat WHERE owner_id = 2;
        ...
        SELECT * FROM cat WHERE owner_id = N;
        ```
        

그렇다면, 쿼리 수를 어떻게 줄일까?

### 그렇다면 **FetchType.EAGER라서 발생하는 것일까?**

---

- FetchType 설정으로 인하여 발생한다는 것은 오해이다.
- FetchType을 변경하는 것은 단지 N+1 발생 시점을 연관관계 데이터를 사용하는 시점으로 미룰지,
    
    아니면 초기 데이터 로드 시점에 가져오느냐에 차이만 있는 것이다.
    

### N+1 문제 발생 이유

---

- `jpaRepository`에 정의한 인터페이스 메소드를 실행하면 → `JPA`는 메소드 이름을 분석해서 `JPQL`을 생성하여 실행하게 된다.
- `JPQL`은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 한다.
- 그렇기 때문에 JPQL은 findAll()이란 메소드를 수행하였을 때 해당 엔티티를 조회하는 `select * from Owner` 쿼리만 실행하게 되는것이다.
    
    **JPQL 입장에서는 연관관계 데이터를 무시하고 해당 엔티티 기준으로 쿼리를 조회하기 때문**이다. 
    

따라서 연관된 엔티티 데이터가 필요한 경우, FetchType으로 지정한 시점에 조회를 별도로 호출하게 된다.

### 해결방안 (1) - Fetch Join

---

사실 우리가 원하는 코드는 각 owner_id마다 select * cat을 하는 것이 아니라,

 `select * from owner left join cat on cat.owner_id = owner.id` 일 것이다. 

- Fetch Join을 사용해 최적화된 쿼리를 우리가 직접 사용할 수 있다.
- 하지만 이는 jpaRepository에서 제공해주는 것은 아니고 JPQL로 작성해야 한다.

```sql
@Query("select o from Owner o join fetch o.cats")
List<Owner> findAllJoinFetch();
```

- 실제로는 INNER JOIN으로 호출되는 것을 확인할 수 있다.
- 이는 연관관계가 있을 경우에도 하나의 쿼리 문으로 표현할 수 있으므로 매우 유리하다.

> Fetch Join의 단점은 없을까?

1. 우리가 연관관계 설정해놓은 `FetchType`을 사용할 수 없다. Fetch Join을 사용하게 되면 데이터 호출 시점에 모든 연관 관계의 데이터를 가져오기 때문에 FetchType을 Lazy로 해놓는것이 무의미하다.

2. 페이징 쿼리를 사용할 수 없다. 하나의 쿼리문으로 가져오다 보니 페이징 단위로 데이터를 가져오는것이 불가능하다.


### 해결방안 (2) - EntityGraph

---

- Fetch join과 동일하게 `JPQL`을 사용하여 query 문을 작성하고 필요한 연관관계를 `EntityGraph`에 설정하면 된다.
- Fetch join과는 다르게 join 문이 outer join으로 실행된다.

```sql
@EntityGraph(attributePaths = "cats")
@Query("select o from Owner o")
List<Owner> findAllEntityGraph();
```

- **Fetch Join과 EntityGraph 주의할 점**
    - 공통적으로 JPQL을 사용하여 JOIN문을 호출한다.
    - 공통적으로 카테시안 곱이 발생하여 Owner의 수만큼 Cat이 중복 데이터가 존재할 수 있다.
        
        따라서 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야 한다.
        

- **중복된 데이터 제거하는 법**
    - 컬렉션을 Set으로 사용 (중복 허용하지 않는 자료구조)
    - JPQL에서 `distinct`를 사용하여 중복된 데이터 조회하지 않기

### 해결방법 (3) - **FetchMode.SUBSELECT**

---

- 두번의 쿼리로 해결하는 방법
- 해당 엔티티를 조회하는 쿼리는 그대로 발생하고, `(1번 쿼리)`
    
    연관관계의 데이터를 조회할 때 서브 쿼리로 함께 조회하는 방법이다. `(2번 쿼리)`
    

```sql
//Owner 엔터티일 때

@Fetch(FetchMode.SUBSELECT)
@OneToMany(mappedBy = "owner", fetch = FetchType.EAGER)
private Set<Cat> cats = new LinkedHashSet<>();
```

- 즉시로딩으로 설정하면 조회 시점에,
    
    지연로딩으로 설정하면 지연로딩된 엔티티를 사용하는 시점에 위의 쿼리가 실행됨 
    
- 모두 지연로딩으로 설정하고 성능 최적화가 필요한 곳에는 JPQL 페치 조인을 사용하는 것을 추천!

### 해결방법 (4) - BatchSize

---

- 하이버네이트가 제공하는 `org.hibernate.annotations.BatchSize` 어노테이션을 이용
- 연관된 엔티티를 조회할 때 지정된 size 만큼 SQL의 IN절을 사용해서 조회한다.

```sql
//Owner 엔터티 클래스일 때
@BatchSize(size=5)
@OneToMany(mappedBy = "owner", fetch = FetchType.EAGER)
private Set<Cat> cats = new LinkedHashSet<>();
```

- `@BatchSize`가 있으므로 Cat의 row 갯수만큼 추가 SQL을 날리지 않고,
    
    조회한 Owner 의 id들을 모아서 **SQL IN 절**을 날린다.
    
- `size`는 IN절에 올수있는 최대 인자 개수를 말한다.
    
    만약 Cat의 개수가 10개라면 위의 IN절이 2번 실행될 것이다.
    

- 즉시로딩: Owner를 조회하는 시점에 Cat를 같이 조회
- 만약 지연 로딩이라면 지연 로딩된 엔티티 최초 사용시점에 5건을 미리 로딩해두고,
    
    6번째 엔티티 사용 시점에 다음 SQL을 추가로 실행한다.
    

### 해결방법 (5) - **QueryBuilder**

---

- Query를 실행하도록 지원해주는 다양한 플러그인 중 하나
    - Mybatis, QueryDSL, JOOQ, JDBC Template 등
- 이를 사용하면 로직에 최적화된 쿼리를 구현할 수 있다.

```sql
// QueryDSL로 구현한 예제
return from(owner).leftJoin(owner.cats, cat)
                   .fetchJoin()
```

### 결론

---

- `Fetch Join`이나 `EntityGraph`를 사용한다면…
    - Join문을 이용하여 하나의 쿼리로 해결할 수 있지만 중복 데이터 관리가 필요하고 FetchType을 어떻게 사용할지에 따라 달라질 수 있다.
- `SUBSELECT`는 두번의 쿼리로 실행되지만 FethType을 EAGER로 설정해두어야 한다는 단점이 있다.
- `BatchSize`는 연관관계의 데이터 사이즈를 정확하게 알 수 있다면 최적화할 수 있는 size를 구할 수 있겠지만 사실상 연관 관계 데이터의 최적화 데이터 사이즈를 알기는 쉽지 않다.
- JPA 만으로는 실제 비즈니스 로직을 모두 구현하기 부족할 수 있다. 다양한 비즈니스 로직을 복잡한 쿼리를 통해서 구현하다보면 다양한 난관에 부딪힐 수 있다. 그러므로 QueryBuilder를 함께 사용하는 것을 추천한다. 그러면 생각보다 다양한 이슈를 큰 고민없이 바로 해결할 수 있다.

출처 https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1
