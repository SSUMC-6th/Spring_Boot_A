### Web server

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/45755ea8-4641-4769-82a9-c05fbd73cb99)

클라이언트(사용자)가 브라우저 주소창에 url을 입력하여 어떤 페이지를 요청하면, http 요청을 받아들여 정적인 콘텐츠(.html .jpeg .css 등)를 사용자에게 전달해주는 역할

- 대표적 임무
    - HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능을 담당
    - 단순히 저장된 정적 웹 리소스들을 클라이언트로 전달하고, 클라이언트로부터 콘텐츠를 전달받아 저장하거나 처리한다.
    - 사용자로부터 동적인 요청이 들어왔을 때, 해당 요청을 웹 서버 자체적으로 처리하기 어렵기 때문에 WAS에게 요청함.
- 대표적인 웹 서버의 종류: Apache, Nginx, IIS(windows 전용 웹 서버)

### WAS (web application server)

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/72ab5031-ff7f-43cd-bb04-a87025dc525f)

<aside>
💡 클라이언트의 요청에 대해 적절한 데이터를 **동적으로** 만들어주는 서버

</aside>

WAS = Web server + Web container

WAS 또한 웹 서버와 동일하게 HTTP 기반으로 동작

웹 서버가 할 수 있는 기능 대부분이 WAS에서도 처리가 가능하며, 비즈니스 로직(서버사이드 코드)을 처리할 수 있어 사용자에게 동적인 콘텐츠를 전달할 수 있다. 주로 데이터베이스 서버와 같이 수행된다.

⇒ 즉 WAS의 주요 임무는 동적인 요청을 받아 처리해 주는 서버

node.js, spring boot이 해당

### Web server가 필요한 이유?

- 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보낼 때
    - Web Server를 통해 정적인 파일들을 빠르게 보내줄 수 있다.
    - 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.

### WAS가 필요한 이유?

- 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다
    - 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
    - 이때, Web Server만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
    - 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.

### Reverse Proxy

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/2567f15d-db07-4dfa-982c-742faafb4c2b)

<aside>
💡 클라이언트와 웹 서버 간의 중개자 역할을 하는 서버

- 클라이언트로부터의 요청을 대신 받아 웹 서버에 전달하고, 웹 서버의 응답을 클라이언트에게 전달하는 역할
- 이를 통해 리버스 프록시는 웹 서버의 부하를 분산시키고, 보안을 강화하는 등 다양한 기능을 수행
</aside>

- 기본 작동 원리
    - 기본 작동 원리는 클라이언트가 리버스 프록시에 요청을 보내면, 리버스 프록시는 요청을 웹 서버에 전달하고, 웹 서버는 요청된 데이터를 처리한 후 리버스 프록시에게 응답을 보낸다. 그리고 리버스 프록시는 웹 서버로부터 받은 응답을 클라이언트에게 전달하는 방식으로 동작
- 필요성
    - 서버 부하 분산
        - 리버스 프록시는 들어오는 요청을 여러 대의 서버로 분산시켜 각 서버의 부하를 줄이고, 서버의 가용성을 높여 안정적인 서비스 제공이 가능
    - 보안 강화
        - 리버스 프록시는 외부에서 직접 서버에 접근하지 못하도록 하여 웹 서비스의 보안을 강화
        - 클라이언트 요청은 먼저 리버스 프록시를 거쳐 서버로 전달되며, 이 과정에서 리버스 프록시는 악성 요청 필터링, 접근 제한 등의 역할을 수행하여 서버를 보호
    - 캐싱 및 가속화
        - 리버스 프록시는 자주 사용되는 정적 파일들(이미지, CSS, JavaScript 등)을 캐시에 저장하여 빠르게 제공 ⇒ 서버의 부하를 줄이고 응답 시간을 단축시켜 웹 서비스의 성능을 향상
    - 서버가 누구인지를 감추는 역할
        - 클라이언트는 리버스 프록시 서버를 먼저 호출하게 되기 때문에 실제 서버의 IP를 알 수 없음
- 단점
    - 추가적인 서버 설정과 관리, 네트워크 지연, 복잡성 증가

- nginx에서 리버스 프록시 설정

```bash
location / {
                proxy_pass http://localhost:3000; <- 프록시 설정
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }
```

### **forward proxy, reverse proxy** 비교

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/12413bab-c080-46c1-94e1-2156a7c54a1b)

- Forward Proxy 서버는 클라이언트 앞에 놓여져 있는 반면, Reverse Proxy 서버는 웹서버/WAS 앞에 놓여 있다.
- 클라이언트 대신 프록시 서버가 목적 서버에 통신해주는 구성
- Forward Proxy는 클라이언트가 **직접 서버 URL로 요청**을 보내고 타겟 서버의 주소가 내부망에서 포워드 프록시에 전달되어, 포워드 프록시가 요청을 보내게 되어 서버에게 클라이언트를 감출 수 있다 (서버가 응답받은 IP는 포워드 프록시 서버의 IP이기 땜클라이언트가 누군지 알 수 없음)
⇒ 클라이언트가 www.abc.com에 직접 요청시, 포워드 프록시 서버가 www.abc.com의 리소스를 대신 받아와서 클라이언트에게 내민다 (forward)

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/1983f482-31b0-490d-aebc-681375d162c5)


- 반면에 Reverse Proxy에서 클라이언트는 웹서비스에 접근할때 웹서버에 요청하는 것이 아닌, **프록시로 요청하고**, 프록시가 배후(reverse)의 서버로부터 데이터를 가져온다.
- 프록시 서버 URL로만 접근이 가능하여 본 서버의 IP 정보를 숨길 수 있다.
- 클라이언트쪽으로 데이터(response)를 밀어주는게 **포워드**라면, 그 반대편인 서버 쪽으로 데이터(request)를 밀어주는 것이 **리버스 프록시**