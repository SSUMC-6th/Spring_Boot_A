keyword : TCP

> TCP/IP 프로토콜의 `전송 계층`에서 사용되는 프로토콜, IP 프로토콜 기반 구현
(전송 계층: IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하는 계층)

데이터 송신이 `양방향`이고, 신뢰성이 요구되는 애플리케이션에 사용
> 

### TCP의 특징

- `연결형 서비스` (3-way handshaking, 4-way handshaking)
- `흐름제어` → 데이터 처리 속도를 조절
    - 송신하는 곳에서 매우 빠르게 데이터를 보내서 문제가 생기지 않도록, 수신자가 수신량을 정할 수 있음
- `혼잡제어` → 데이터의 양을 조절
    - 패킷의 수가 넘치지 않도록, 정보가 과다하면 패킷을 조금만 전송
- `신뢰성` → ACK을 통한 이상 감지
- 순서대로 데이터 전송

### ACK 제어비트

- 송신측에 대해 **수신측에서 긍정 응답으로** 보내지는 전송 제어용 char
    - ACK 번호를 사용하여 패킷이 도착했는지 확인
    - 패킷이 제대로 도착하지 않았다면 재송신을 요구

### 3-way handshaking

**TCP 연결을 설정하는 과정 (SYN과 ACK 전달)**

1. 먼저 open()을 실행한 클라이언트가 `SYN`을 보내고 `SYN_SENT` 상태로 대기
2. 서버는 `SYN_RCVD` 상태로 바꾸고 `SYN`과 응답 `ACK`를 보냄
3. `SYN`과 응답 `ACK`을 받은 클라이언트는 `ESTABLISHED` 상태로 변경하고 서버에게 응답 `ACK`를 보냄
4. 응답 `ACK`를 받은 서버 또한 `ESTABLISHED` 상태로 변경

`ESTABLISHED` : 연결 완료

### 4-way handshaking

**TCP 연결을 해제하는 과정 (FIN과 ACK 전달)**

1. 먼저 close()를 실행한 클라이언트가 `FIN`을 보내고 `FIN_WAIT1` 상태로 대기
2. 서버는 `CLOSE_WAIT`으로 바꾸고 응답 `ACK`를 전달. 
동시에 해당 포트에 연결되어 있는 어플리케이션에게 close()를 요청
3. ACK를 받은 클라이언트는 상태를 `FIN_WAIT2`로 변경한다.
4. close() 요청을 받은 서버 어플리케이션은 종료 프로세스를 진행하고 `FIN`을 클라이언트에 보내 `LAST_ACK` 상태로 바꾼다.
5. FIN을 받은 클라이언트는 ACK를 서버에 다시 전송하고 `TIME_WAIT`으로 상태를 바꾼다. `TIME_WAIT`에서 일정 시간이 지나면 `CLOSED`된다. ACK를 받은 서버도 포트를 `CLOSED`로 닫는다.

`CLOSED` : 연결 해제 완료