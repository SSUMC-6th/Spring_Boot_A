

### 멀티 프로세싱

- 여러 개의 프로세스를 동시에 실행하는 것
- 각 프로세스는 독립된 메모리 공간을 가지므로, 데이터 공유 및 통신을 위해 별도의 메커니즘이 필요 → `IPC`(Inter Proces Communication)를 사용
    
    
    | 1번 방식 
    Message Passing 모델  | 메시지를 전달하기 위해 시스템 콜을 호출하여 커널을 들렀다 온다. |
    | --- | --- |
    | 2번 방식 
    Shared Memory 모델:  | 프로세스 사이에 공유 공간을 만들어 메시지를 저장한다. |
- 독립된 메모리 공간을 가지므로, 동기화 문제가 발생하지 않는다.
    - 단, Shared Memory를 사용한다면, 메모리를 공유하게 되기 때문에 동기화 문제가 발생할 수 있음
- 프로세스 간 통신을 위한 추가적인 매커니즘이 필요하다.
- 프로세스를 생성하고 관리하는 데 추가적인 오버헤드가 발생할 수 있다.

### 멀티 쓰레드

- 하나의 프로세스에서 여러 개의 스레드를 동시에 실행하는 것
- 같은 프로세스 내에서 스레드 간의 데이터를 공유할 수 있음
    - 스택 영역만 따로 사용하고, 데이터 영역과 힙 영역을 공유
    - → 따라서 스레드 간의 데이터 공유와 통신이 용이
- **동시성 문제로 인해 스레드 간에 데이터 공유 시 동기화 문제가 발생할 수 있음**
- **하나의 스레드가 오류를 발생시키면 전체 프로세스가 영향을 받을 수 있음**





### 자바의 다중 쓰레드

#### 다중 스레드 사용
    
    ### 다중 쓰레드 사용
    
    ---
    
    - 익명 클래스와 람다식의 형태로 Runnable 객체 정의 → 새 쓰레드 정의하기
    - 두 개의 쓰레드를 만들고, Runnable 객체를 생성자로 전달하고,
        
        쓰레드 동작을 시작하는 전체 코드
        
        ```java
        public class _04_MultiThread {
            public static void main(String[] args) {
                Runnable cleaner1 = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("-- 직원1 청소 시작 --");
                        for (int i = 1; i <= 10; i+=2) {
                            System.out.println("(직원1) " + i + "번방 청소 중");
                            try {
                                Thread.sleep(1000);
                            } catch (InterruptedException e) {
                                throw new RuntimeException(e);
                            }
                        }
                        System.out.println("-- 직원1 청소 끝 --");
                    }
                };
        
                Runnable cleaner2 = () -> {
                    System.out.println("-- 직원2 청소 시작 --");
                    for (int i = 2; i <= 10; i+=2) {
                        System.out.println("(직원2) " + i + "번방 청소 중");
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    System.out.println("-- 직원2 청소 끝 --");
                };
        
                Thread cleanerThread1 = new Thread(cleaner1);
                Thread cleanerThread2 = new Thread(cleaner2);
        
                cleanerThread1.start();
                cleanerThread2.start();
        
            }
        }
        ```
        
- 이렇게하면 두 쓰레드가 동시에 동작하게 됨.






##### 동기화 문제 해결
    
    
    각 쓰레드가 각자의 동작을 수행하는 것이 아니라,

동시에 하나의 동작(메소드)을 같이 수행해야 할 때는 어떻게 할까?

### 두 개 이상의 쓰레드에서 하나의 메소드에 접근할 때

---

- 직원 1과 직원 2가 순서대로 1번 방부터 10번 방까지 같이 청소를 수행하되,
    
    겹치지 않게 비어 있는 방을 각자 5개씩 청소하기.
    
    ```java
    public class Room {
        public int number = 1; //초기화
    
    		//수행할 메소드
        public void clean(String name) {
            // 직원1 : 3번방 청소 완료
            System.out.println(name + " : " + number + "번방 청소 중");
            number++;
        }
        //메소드를 호출할 때마다 순서대로 방 번호가 올라감
    
    }
    ```
    
    ```java
    //메인 클래스
    public class _05_Synchronization {
        public static void main(String[] args) {
    				
            Room room = new Room();
    
            Runnable cleaner1 = new Runnable() {
                @Override
                public void run() {
                    System.out.println("-- 직원1 청소 시작 --");
                    for (int i = 1; i <= 5; i++) { //5개씩
                        room.clean("직원1");
                    }
                    System.out.println("-- 직원1 청소 끝 --");
                }
            };
    
            Runnable cleaner2 = () -> {
                System.out.println("-- 직원2 청소 시작 --");
                for (int i = 1; i <= 5; i+=1) {
                    room.clean("직원2");
                }
                System.out.println("-- 직원2 청소 끝 --");
            };
    
            Thread cleanerThread1 = new Thread(cleaner1);
            Thread cleanerThread2 = new Thread(cleaner2);
    
            cleanerThread1.start();
            cleanerThread2.start();
        }
    }
    ```
    
    

    - 두 개 이상의 여러 쓰레드에서 동시에 하나의 메소드에 접근해서 변수의 값을 업데이트하려고 했기 때문에 문제 발생. (number++에 접근이 겹침)
    - **→ 동기화 필요 !!**





    
    ### 동기화 문제 해결
    
    - 어떤 쓰레드가 이 메소드에 들어와 작업하고 있으면,
    
    다른 쓰레드는 이 메소드에 진입 자체를 못하도록 막는 것.
    
    - 다른 쓰레드가 접근해 있으면, 앞 작업이 끝날 때까지 기다렸다가 동작 수행

    - 동시에 수행할 메소드 앞에 `synchronized` 키워드 적기 → 메소드가 동기화됨.
    
    ```java
    public class Room {
        public int number = 1;
        synchronized public void clean(String name) {
            System.out.println(name + " : " + number + "번방 청소 중");
            number++;
        }
    }
    ```
    
    - 직원 1 쓰레드가 수행하고 있는 동안엔 직원 2 쓰레드가 메소드를 호출하지 못함
    - 순서대로 메소드에 하나의 쓰레드씩만 들어와 작업


    - 이후 메인 메소드를 실행하면 1번 방부터 10번 방까지 순서대로 잘 수행됨!