Keyword: 멀티 프로세스

<aside>
💡 **왜 accept() 시스템 콜의 리턴 값은 새로운 소켓의 파일 디스크립터인가?**
accept 시스템 콜 이후 곧바로 잔여 3-way handshake와 데이터 송수신이 이루어지는 것이 아니라, 서버의 성능을 위해 또 하나의 테크닉이 들어가게 된다.

</aside>

- 하나의 프로세스인 서버가 클라이언트의 수많은 요청을 받는 상황에서,
    
    백로그 큐의 가장 앞에 있던 클라이언트의 요청을 받고 응답까지 다 주고 다시 다음 요청을 받아준다면, **엄청난 병목이 생길 것**
    
- 따라서 서버는 **연결 요청을 받는 부분 따로, 이후 응답까지 주는 부분을 따로** 나누게 됨

<aside>
📌 accept 시스템 콜의 응답을 받았다
(accept 과정이므로, 잔여 handshake 이전)
= SYN 요청을 보낸 클라이언트가 적어도 하나 있어서 백로그 큐에 있었고 해당 클라이언트의 요청에 대한 이후 응답을 위해 **새로운 소켓을 만들었다.**

</aside>

- 이 새로운 소켓은 fork() 시스템 콜을 통해 생긴 accpet() 시스템 콜의 자식 프로세스
    
    
    | 부모 프로세스 | 부모 프로세스는 연결 요청을 받아주고 자식 프로세스에게
    나머지 일을 맡기고 다시 새로운 연결요청을 받음 |
    | --- | --- |
    | 자식 프로세스 | 부모 프로세스가 새로 만들어준 소켓을 이어받아
    이후 남은 잔여 3-way handshake를 수행 후 데이터 통신을 수행 |
    
    <aside>
    💡 이때 자식 프로세스는 새로운 연결요청을 받지 않고 그저 응답을 준 후 exit(0)를 통해 종료된다!
    
    </aside>