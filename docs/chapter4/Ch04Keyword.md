## Key에 대한 이해

- DB에서 조건을 만족하는 레코드를 찾거나 순서대로 정렬할 때 레코드를 서로 구분할 수 있는 기준이 되는 속성을 의미
- 키의 종류
    - Super key (수퍼키)
    - Candidate key (후보키)
    - Primary key (기본키)
    - Alternate key (대체키)
    - Foreign key (외래키)
    - Composite key (복합키)
- 유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질을 의미 (중복x)
- 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질

# 외래키 (Foreign key)

![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/4013efe2-1252-482d-86de-969b9169fc9e)
테이블간의 관계를 나타낼때 사용하며, 다른 테이블의 기본키를 참조해 외래키로 사용

- 즉, 한 테이블의 외래키는 연결되어있는 다른 테이블의 기본키중 하나다.
- 위의 왼쪽 테이블에서 `student_id`는 기본키이며, 오른쪽 테이블에서는 외래키이다.
    - 학생 목록을 나타내는 왼쪽 테이블에서 1~4의 학생이 있으며, 오른쪽 테이블에서 외래키로 사용되는 `student_id`는 그 외 값이 나타날 수 없다.
- 외래키 설정을 하는 이유: **데이터 무결성**
    - 무결성: 데이터가 항상 정확한 값을 유지하는 성질
    - 위 테이블중 왼쪽 테이블에서 `student_id`가 변경되었는데 오른쪽 테이블의 `student_id`가 변경되지 않았다면 문제가 생긴다. 이런 상황을 예방하기 위해 외래키가 존재

# 기본키 (Primary key)

유일성과 최소성을 가지며(후보키), 해당 레코드를 식별할때 기준이 되는 반드시 필요한 키

- 추가로 기본키는 다음과 같은 조건을 따른다.
    - 값의 변동이 잦은 후보키는 기본키로 부적절하다.
    - NULL값이 허용되지 않는다.
    - 후보키중 단순한 키를 기본키로 선택한다.
    - 하나의 테이블에는 반드시 하나의 기본키만 존재한다.

```sql
id INT PRIMARY KEY // 지정방법 1
id INT NOT NULL,
PRIMARY KEY (id) // 지정방법 2
```

# ER 다이어그램

=ERD, Entity Relationship Diagram의 약어, 데이터베이스 구조를 한눈에 알아보기 위해 사용

- 표준 기호

  ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/4bf6ea06-480b-490b-a547-c99c63238503)

- ERD 예시

  ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/62e0e8b3-4caa-455a-8c88-01d41630b66e)

- 새발 표기법
    - 관계의 의미나 제약조건 등은 개체 타입들을 연결하는 실선 위에 몇 가지 기호를 사용하여 표현하는 표기법.

      ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/e8171ef6-76b1-44d7-a815-2a809198bb78)
    - ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/ad216e98-42c3-454c-895a-c332ffb18ce9)


# 복합 키

- 두개 이상의 컬럼을 묶어서 하나의 기본키로 지정하는것.
- 기본키는 하나의 테이블에 하나만 존재할 수 있다, 또한 기본키는 하나 이상의 컬럼으로 구성되어 있다.
    - 기본키가 만약 복합키라면, 복합키 또한 당연히 유일성과 최소성을 만족해야한다.

```sql
CREATE TABLE user (
id INT NOT NULL,
name VARCHAR(50),
PRIMARY KEY (id, name)
);
```

# 연관관계

- 관계 타입 유형
    1. 1:1 (일대일)
        - 개체 집합 A의 각 원소가 개체 집합 B의 원소 1개와 대응

          ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/9911791a-bf14-410c-9891-a95559376c58)
          (한명의 교수는 한과목만 강의 하고, 한개의 과목은 한명의 교수에 의해 강의되어진다.)

    2. 1:N (일대다)
        - 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응할 수 있고, 개체 집합 B의 각 원소는 개체 집합 A의 원소 1개와 대응

          ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/2fd75b2c-41bc-4356-881a-24e42d3d1b0c)

          (한학과에는 여러명의 학생이 있을 수 있고 한학생은 한개의 학과에 소속 된다.)

    3. N:M (다대다)
        - 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러개와 대응할 수 있고, 개체 집합 B의 각 원소는 개체 집합 A의 원소 여러 개와 대응할 수 있음

          ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/c4054906-753c-4600-bc19-9a085311f79d)

          (한명의 학생은 여러과목을 수강할 수 있고, 한 과목은 여러명의 학생에 의해 수강되어 질 수 있다.)


# 정규화

- 이상현상: 한 개의 릴레이션에 두 개 이상의 속성이 포함되어 있고 기본키가 아닌 속성이 결정자일 때 발생
- 정규화: 이상현상이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정
- 목표: 테이블 간에 중복된 데이터를 허용하지 않는 것
    - 중복된 데이터 허용하지 않음으로써 무결성 유지, DB 저장 용량 줄일 수 있음.
    - 이러한 테이블을 분해하는 정규화 단계가 정의되어 있다.
1. 제1 정규화
    - 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것 → 모든 속성 값이 원자값을 갖는 경우.

      ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/376899c0-cb16-4510-a678-9e326de01e02)

      위 테이블에서 추신수와 박세리는 여러개의 취미를 가지고 있으므로 제1정규형을 만족하지 못한다. → 속성들을 다른 열로 분해

2. 제2 정규화
    - 릴레이션이 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때를 의미
    - 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것

      ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/eaaa6e4e-649a-47db-8cfb-69aea5498a02)

        - 이 테이블에서 기본키는 (학생번호, 강좌이름)으로 복합키, 기본키는 성적을 관리하고 있음. 강의실은 기본키의 부분집합인 강좌이름에 의해 결정
          ⇒ 기본키의 부분키인 강좌이름이 결정자기 때문에, 강의실을 기존 테이블에서 분해하여 별도의 테이블로 관리해야 제2 정규형을 만족시킬 수 있다.

      ![image](https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/bfd8bb7e-1207-4de2-b2b2-d7e7a1534210)

3. 제3 정규화
    - 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
    - 이행정 종속이란 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미
     <img width="914" alt="image" src="https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/37a6e3b4-bab1-4ab9-9ee2-bd20c4356981">
    - 기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다.
      - 이행적 종속을 제거하는 이유: 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경되는 경우 501번의 학생은 스포츠경영학이라는 수업을 20000원이라는 수강료로 듣게 된다.
        <img width="672" alt="image" src="https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/10ce7c56-6d3e-40e4-a07a-ebf0687a9a23">
      - 학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해


4. BCNF 정규화
    
    - 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
    <img width="857" alt="image" src="https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/50ba1dcf-aa3a-435a-91a2-114e48ec2197">
   - 특강수강 테이블에서 기본키는 (학생번호, 특강이름)이다. 그리고 기본키 (학생번호, 특강이름)는 교수를 결정. 또한 여기서 교수는 특강이름을 결정
    
        -> 교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니다. BCNF 정규화를 만족시키기 위해서 다음과 같이 특강신청 테이블과 특강교수 테이블로 분해한다.
   <img width="755" alt="image" src="https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/b0c122fd-95de-471d-ab1a-18d9b833594e">

     - 대부분의 릴레이션에서는 BCNF까지 정규화하면 실제적인 이상현상이 없어지기 때문에 BCNF 까지 정규화한다.
       <img width="675" alt="image" src="https://github.com/SSUMC-6th/Spring_Boot_A/assets/118423039/50afc7ee-f7a9-4a1b-8df3-a7d3d974a971">


# 반 정규화
- 정규화의 단점: Relation의 분해로 인해 Relation 간의 연산(JOIN 연산)이 많아져서 질의에 대한 응답 시간이 느려질 수 있다.
  -   이러한 단점에 대한 대응책: 반정규화를 적용


- 반정규화: 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나


- 언제 사용되는가?
  
    - 디스크 I/O 량이 많아서 조회 시 성능이 저하될 때.
    -  테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상될 때 
    - 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상될 때


- 무엇이 반정규화의 대상이 되는가?
  - 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많은 경우
  - 항상 일정한 범위만을 조회하는 경우
   - 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우
  - 성능 상 이슈가 있을 경우
  - 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우
  
  
- 반정규화 과정에서 주의할 점은?
  - 반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다.
  - 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.
